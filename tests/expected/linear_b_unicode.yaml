# Test LB.A.1:
# Scenario: Test that blank spaces act as word separators within text in annotated scenarios (except for in specific scenarios, e.g. between a domesticated animal ideogram and a sex indicator).
# Requirements mapping:
    # LB.1-x: Tokenise each blank space (including Unicode '\u00a0') and use to distinguish individual words. Represent as is in both annotated and regularised output. 
        # This should occur in all but the specified exception scenarios (see LB.1-aâ€“d).
    # LB.1-e: If a blank space appears after a domesticated animal ideogram (i.e. EQU, SUS, OVIS, BOS or CAP) and before either a lowercase 'm' 'f' or  'x', then remove the space in both the annotated and regularized outputs.

    "CAP f 130 SUS 17 SUS f 41 BOS m 2 BOS f 4": "ğ‚ˆ 130 ğ‚ 17 ğ‚Š 41 ğ‚ 2 ğ‚Œ 4"
    "]SUS x 4 KO 80[" : "]ğ‚ 4 ğ€’ 80["

# Test LB.A.2:
# Scenario: Test that hyphens act as sign separators within a word in annotated scenarios.
# Requirements mapping: 
    # LB.2: Tokenise each instance of '-' and use to recognise whole words in encoding, but do not represent this symbol in either the annotated or the regularised output.
    
    "a-ri-to-jo" : "ğ€€ğ€ªğ€µğ€"

# Test LB.A.3
# Scenario: Test that blank spaces after * and before and after '+' are removed in annotated scenarios.
# Requirements mapping:
    # LB.1-a: If a blank space appears after '*', then remove that space in both the annotated and regularized outputs.
    # LB.1-b: If a blank space appears before/after '+', then remove both those spaces in both the annotated and regularized outputs.

    "]qa-ra / re-me-to * 168 + SE 28" : "]ğ€£ğ€¨ / ğ€©ğ€•ğ€µ ğ‚°+ğ€® 28"

# Test LB.A.4
# Scenario: Test that '--' is treated the same as as '-' in annotated scenarios.
# Requirements mapping:
    # LB.3: Tokenise each instance of '--' as '-' and use to recognise whole words in encoding, but do not represent this symbol in either the annotated or the regularised output.

    "a-ka--[ ]--jo-jo , me-no-[ da-pu2-ri-[-to-jo ]-po-ti-ni-ja ri *166+WE 22-[" : "ğ€€ğ€[ ]ğ€ğ€ , ğ€•ğ€œ[ ğ€…ğ†ğ€ª[ğ€µğ€ ]ğ€¡ğ€´ğ€›ğ€Š ğ€ª ğ‚®+ğ€¸ 22[" # https://liber.cnr.it/tablet/view/124

# Test LB.A.5
# Scenario: Test that ']', '[', ',' and '/' are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.4: Tokenise each instance of '/'. Represent this symbol as is in the annotated output, but do not include in the regularised output.
    # LB.5: Tokenise each instance of '//'. Represent this symbol as is in the annotated output, but do not include in the regularised output.
    # LB.6: Tokenise each instance of ','. Represent this symbol as is in the annotated output, but do not include in the regularised output.
    # LB.9: Tokenise each instance of '['. Represent this symbol as is in the annotated output, and represent as wildcard (i.e. '%') in regularised output.
    # LB.10: Tokenise each instance of ']'. Represent this symbol as is in the annotated output, and represent as wildcard (i.e. '%') in regularised output.

    "wo-de-wi-jo-jo , / me-no[ // ]ri-jo-de , ko-no , MA 3 ko-ri[ ]2 pa-de-i , ko-no MA 2 KO T 1[ [ ] pa-si-te-o-i , pa-sa-ja , ko-no , [ ] a-mi-ni-so-de , MA 2 KO T 4" : "ğ€ºğ€†ğ€¹ğ€ğ€ , / ğ€•ğ€œ[ // ]ğ€ªğ€ğ€† , ğ€’ğ€œ , ğ€” 3 ğ€’ğ€ª[ ]2 ğ€ğ€†ğ€‚ , ğ€’ğ€œ ğ€” 2 ğ€’ ğ„¼ 1[ [ ] ğ€ğ€¯ğ€³ğ€ƒğ€‚ , ğ€ğ€­ğ€Š , ğ€’ğ€œ , [ ] ğ€€ğ€–ğ€›ğ€°ğ€† , ğ€” 2 ğ€’ ğ„¼ 4"

# Test LB.A.6
# Scenario: Test that ':' is correctly printed in annotated scenarios.
# Requirements mapping: 
    # LB.7: Tokenise each instance of ':'. Represent this symbol as is in the annotated output, but do not include in the regularised output.

    "a-ta-ti-nu  :  si-wa-[" : "ğ€€ğ€²ğ€´ğ€  :  ğ€¯ğ€·["

# Test LB.A.7
# Scenario: Test that single quotation marks are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.8: Tokenise each instance of '''. Represent this symbol as is in the annotated output, but do not include in regularised output.

    "]wa VIR 1 MUL 2 'ko-wa 1' ko-wo 1" : "]ğ€· ğ‚€ 1 ğ‚ 2 'ğ€’ğ€· 1' ğ€’ğ€º 1"

# Test LB.A.8
# Scenario: Test that '\u0323' is not printed in annotated scenarios
# Requirements mapping:
    # LB.11: Ignore each instance of 'XÌ£' (or '\u0323') in tokenisation. Do not represent this symbol in either the annotated or the regularised output.

    "] ko-wo / m\u0323e\u0323[-zo] 1 ko-wo / me-wi-jo 2 [" : "] ğ€’ğ€º / ğ€•[ğ€¿] 1 ğ€’ğ€º / ğ€•ğ€¹ğ€ 2 ["

# Test LB.A.9
# Scenario: Test that '?' is correctly printed in annoted scenarios.
# Requirements mapping:
    # LB.12: Tokenise each instance of '?'. Represent this symbol as is in the annotated output, but do not include in the regularised output.

    "i[-qi-ja?": "ğ€‚[ğ€¥ğ€Š?"

# Test LB.A.10
# Scenario: Test that \u27e6 and \u27e7 are correctly printed as Scott brackets (i.e. 'âŸ¦' and 'âŸ§') in annotated scenarios.
# Requirements mapping:
    # LB.13: Tokenise each instance of Scott brackets (i.e. 'âŸ¦' and 'âŸ§', or '\u27e6' and '\u27e7'). Represent these symbols as is in the annotated output. Do not include these symbols, or any other text that they contain, in the reguarised ouput.
       
    "po-*34-wi-do \u27e6TUN\u27e7 BIG[" : "ğ€¡ğ“ğ€¹ğ€ˆ âŸ¦ğ‚ªâŸ§ ğƒŒ["

# Test LB.A.11
# Scenario: Test that '<' and '>' are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.14: Tokenise each instance of angle brackets (i.e. '<' and '>'). Represent this text as is in the annotated output. Do not include these symbols, or any other text that they contain, in the reguarised ouput.
    
    "] <OVIS:m> 69 OVIS:f 30 [ ]-e-ke-me-de , / tu-ni-ja , pa OVIS:m 1" : "] <ğ‚‡> 69 ğ‚† 30 [ ]ğ€ğ€ğ€•ğ€† , / ğ€¶ğ€›ğ€Š , ğ€ ğ‚‡ 1" # https://liber.cnr.it/tablet/view/3172?wl=12765

# Test LB.A.12
# Scenario: Test that lower half brackets (i.e. 'â¸¤' and 'â¸¥', or '\u2e24' and '\u2e25') are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.15: Tokenise each instance of lower half brackets (i.e. 'â¸¤' and 'â¸¥', or '\u2e24' and '\u2e25'). Represent these symbols as is in the annotated output. Do not include these symbols in the reguarised ouput.
    
    "du-to\u2e24 \u2e25 / r\u0323u\u0323-ki-to" : "ğ€‰ğ€µâ¸¤ â¸¥ / ğ€¬ğ€‘ğ€µ"
    "e-ke-qe ]-o-na-to , ke-ke-me-naâŒ âŒŸko-to-na GRA qs ] vac.": "ğ€ğ€ğ€¤ ]ğ€ƒğ€™ğ€µ , ğ€ğ€ğ€•ğ€™âŒ âŒŸğ€’ğ€µğ€™ ğ‚ qs ] vac."

# Test LB.A.13
# Scenario: Test that upper half brackets (i.e. 'âŒœ' and 'âŒ') are correctly printed in annotated scenarios.
# Requirements mapping
    # LB.16: Tokenise each instance of upper half brackets (i.e. ' âŒœ' and 'âŒ'). Represent these symbols as is in the annotated output. Do not include these symbols in the reguarised ouput.

    "]2 OLIV T 2 ] OLIV T 1 to]-ko-do-mo HORD[ ]Z 3 VIR 20[ pi-ri-e-te-re HORD[ ]Z 3 VIR 5 pa-te-ko-toâŒœ âŒHORD[ ]V 2 [ vacat qa-ra2-te , o[-pi-me-]ne[ ]OLIV 6 pa-ka , o-pi-me-ne , [ OLIV qs pa-te-ko-to , o-pi-me-ne[ ]HORD 1 [ pi-ri-e-te-si , o-pi-me-ne[ ]HORD 1 T 4[ to-ko-do-mo , o-pi-me-ne[ ]HORD 7[ ]5 vac." : "]2 ğ‚ ğ„¼ 2 ] ğ‚ ğ„¼ 1 ğ€µ]ğ€’ğ€ˆğ€— ğ‚[ ]ğ„¿ 3 ğ‚€ 20[ ğ€ ğ€ªğ€ğ€³ğ€© ğ‚[ ]ğ„¿ 3 ğ‚€ 5 ğ€ğ€³ğ€’ğ€µ âŒœ   âŒ ğ‚[ ]ğ„¾ 2 [ vacat ğ€£ğˆğ€³ , ğ€ƒ[ğ€ ğ€•]ğ€š[ ]ğ‚ 6 ğ€ğ€ , ğ€ƒğ€ ğ€•ğ€š , [ ğ‚ qs ğ€ğ€³ğ€’ğ€µ , ğ€ƒğ€ ğ€•ğ€š[ ]ğ‚ 1 [ ğ€ ğ€ªğ€ğ€³ğ€¯ , ğ€ƒğ€ ğ€•ğ€š[ ]ğ‚ 1 ğ„¼ 4[ ğ€µğ€’ğ€ˆğ€— , ğ€ƒğ€ ğ€•ğ€š[ ]ğ‚ 7[ ]5 vac."

# Test LB.A.14
# Scenario: Test that \u2082 is correctly handled as a subscript '2' in annotated scenarios.
# Requirements mapping:
    # LB.17: Tokenise '\u2082' together with immediately preceding transliterated sign (as long as no hyphen '-' is between them). Confirm that it is treated correctly as a subscript '2', and expected Unicode sign is printed, as per mapping.

    "da-pu\u2082-ri-to-jo , / po-ti-ni-ja 'me-ri' * 209 VAS 1" : "ğ€…ğ†ğ€ªğ€µğ€ , / ğ€¡ğ€´ğ€›ğ€Š 'ğ€•ğ€ª' ğƒ¨ 1"

# Test LB.A.15
# Scenario: Test that '\u2083' is correctly handled as a subscript '2' in annotated scenarios
# Requirements mapping:
    # LB.18: Tokenise '\u2083' together with immediately preceding transliterated sign (as long as no hyphen '-' is between them). Confirm that it is treated correctly as a subscript '3', and expected Unicode sign is printed, as per mapping.

    "pu-ri / a\u2083-zo-ro-qe , po-da-ko-qe BOS m ZE 1[" :  "ğ€¢ğ€ª / ğğ€¿ğ€«ğ€¤ , ğ€¡ğ€…ğ€’ğ€¤ ğ‚ ğ€½ 1["

# Test LB.R.16
# Scenario: Test that 'mutila' is correctly printed in annotated scenarios.
# Requirements mapping:
    # LB 19: Tokenise each instance of 'mutila'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "] GRA[ qs mutila" : "] ğ‚[ qs  mutila "

# Test LB.A.17
# Scenario: Test that 'mut' is correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.20: Tokenise each instance of 'mut'. Represent this text as is in the annotated output, but do not include in the regularised output.
    
    "sup. mut. ]vacat [ ]A 5 A [ ]vest.[ inf. mut" : "sup. mut. ]vacat [ ]ğ€€ 5 ğ€€ [ ]vest.[ inf. mut"

# Test LB.A.18
# Scenario: Test that 'sup. mut.', 'inf. mut.' and 'vac.' are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.21: Tokenise each instance of 'sup.' and 'mut.'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.22: Tokenise each instance of 'inf.' and 'mut.'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.23: Tokenise each instance of 'vac.'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "sup. mut. ] wo[ ] vac. [ inf. mut." : "sup. mut. ] ğ€º[ ] vac. [ inf. mut."

# Test LB.A.19
# Scenario: Test that 'vacat' is correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.24: Tokenise each instance of 'vacat'. Represent this text as is in the annotated output, but do not include in the regularised output.
    
    "] vacat [" : "] vacat ["
    "] vacat v. ] 1" : "] vacat v. ] 1"

# Test LB.A.20
# Scenario: Test that 'vest.' is correctly printed in annotated scenarios, and that Unicode '\u00a0' is treated as a blank space.
# Requirements mapping:
    # LB.1-x: Tokenise each blank space (including Unicode '\u00a0') and use to distinguish individual words. Represent as is in both annotated and regularised output. 
        # This should occur in all but the specified exception scenarios (see LB.1-aâ€“d).
    # LB.25: Tokenise each instance of 'vest.'. Represent this text as is in the annotated output, and represent as wildcard (i.e. '%') in regularised output.

    "] vest ., / su-ri-mo , u-ta-jo-jo , o OVIS m 85[\u00a0] vac ." : "] vest., / ğ€±ğ€ªğ€— , ğ€„ğ€²ğ€ğ€ , ğ€ƒ ğ‚‡ 85[ ] vac."

# Test LB.R.21
# Scenario: Test that 'vestigia' is correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.26: Tokenise each instance of 'vestigia'. Represent this text as is in the annotated output, and represent as wildcard (i.e. '%') in regularised output.

    "pa-ro , we-u-da-ne-we re-u-ko , a-ko-ro-we-e BOS+SI 2 re[-u-]ko , ma-ra-pi , pe-ko , a-ko-ro-we BOS+SI 1 OVIS:m? ]3 CAP:m 3 WE 3 CAP:m 3 ]vestigia[ ]2 [ ]BOS:x 3 âŸ¦ âŸ§ ] vest. [ ] vest. [ re-u-ko[ ]ma-ra[-pi ]pe-ko , a-ko-ro-we[ OVIS:m 1 CAP:m 1 WE[ ] SUS:x[ ] vacat [ inf. mut." : "ğ€ğ€« , ğ€¸ğ€„ğ€…ğ€šğ€¸ ğ€©ğ€„ğ€’ , ğ€€ğ€’ğ€«ğ€¸ğ€ ğ€˜+ğ€¯ 2 ğ€©[ğ€„]ğ€’ , ğ€”ğ€¨ğ€  , ğ€Ÿğ€’ , ğ€€ğ€’ğ€«ğ€¸ ğ€˜+ğ€¯ 1 ğ‚‡? ]3 ğ‚‰ 3 ğ€¸ 3 ğ‚‰ 3 ]vestigia[ ]2 [ ]ğ€˜ 3 âŸ¦ âŸ§ ] vest. [ ] vest. [ ğ€©ğ€„ğ€’[ ]ğ€”ğ€¨[ğ€  ]ğ€Ÿğ€’ , ğ€€ğ€’ğ€«ğ€¸[ ğ‚‡ 1 ğ‚‰ 1 ğ€¸[ ] ğ‚[ ] vacat [ inf. mut."

# Test LB.A.22
# Scenario: Test that 'vestigia?' is correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.27: Tokenise each instance of 'vestigia?'. Represent this text as is in the annotated output, and represent as wildcard (i.e. '%') in regularised output.

    "su-ma-no / ti-ri-to [ vestigia? ] vacat" : "ğ€±ğ€”ğ€œ / ğ€´ğ€ªğ€µ [ vestigia? ] vacat"

# Test LB.A.23
# Scenario: Test that 'qs' (i.e. 'quantum sufficit') is correctly printed in annoted scenarios.
# Requirements mapping:
    # LB.28: Tokenise each instance of 'qs'. Represent this text as is in the annotated output, but represent as wildcard (i.e. '%') in regularised output.

    "]-ke-ke-me-na-[ , ko-]-to-na GRA qs ] vac." : "]ğ€ğ€ğ€•ğ€™[ , ğ€’]ğ€µğ€™ ğ‚ qs ] vac."

# Test LB.A.24
# Scenario: Test that 'fragmentum separatum', 'Î±', 'Î²', 'Î³' and 'Î´'  are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.29: Tokenise each instance of 'fragmentum separatum'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.53: Tokenise each instance of 'Î±'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.54: Tokenise each instance of 'Î²'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.55: Tokenise each instance of 'Î³'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.56: Tokenise each instance of 'Î´'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "da-we-u[-pi ]a-ko[ da-we-u-pi , a[ da-we-u-pi , ka[ da-we-u-pi , e-[ a3-zo-wo[ da-we[-u-]pi âŒ âŒŸwo[ da-we-u-pi , e-ke[ da-we-u[-pi a-re[ a-zo[ inf. mut. fragmentum separatum Î± sup. mut. ]  OVIS:f X 15 [ fragmentum separatum Î² ] , ka[ fragmentum separatum Î³ sup. mut. ]no-wo[ fragmentum separatum Î´ sup. mut. ]ma-jo-wo-[ inf. mut." : "ğ€…ğ€¸ğ€„[ğ€  ]ğ€€ğ€’[ ğ€…ğ€¸ğ€„ğ€  , ğ€€[ ğ€…ğ€¸ğ€„ğ€  , ğ€[ ğ€…ğ€¸ğ€„ğ€  , ğ€[ , ğğ€¿ğ€º[ ğ€…ğ€¸[ğ€„]ğ€   âŒ âŒŸğ€º[ ğ€…ğ€¸ğ€„ğ€  , ğ€ğ€[ ğ€…ğ€¸ğ€„[ğ€  ğ€€ğ€©[ ğ€€ğ€¿[ inf. mut. fragmentum separatum Î± sup. mut. ]  ğ‚† X 15 [ fragmentum separatum Î² ] ğ€[ fragmentum separatum Î³ sup. mut. ]ğ€œğ€º[ fragmentum separatum Î´ sup. mut. ]ğ€”ğ€ğ€º[ inf. mut."

# Test LB.A.25
# Scenario: Test that 'fragmentum A' and 'fragmentum B' are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.30: Tokenise each instance of 'fragmentum A'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.31: Tokenise each instance of 'fragmentum B'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "fragmentum A fragmentum B vacat [ sup. mut. e-me-si-jo-jo-[ ] 3-[ pa-na-so GRA 100-[ ]-vac.-[ ta-ra-qo GRA [ inf. mut. ta-u-pa-du-we GRA-[ a-ro-ja-[ pu-na-so-[ inf. mut." : "fragmentum A fragmentum B vacat [ sup. mut. ğ€ğ€•ğ€¯ğ€ğ€[ ] 3[ ğ€ğ€™ğ€° ğ‚ 100[ ]vac.[ ğ€²ğ€¨ğ€¦ ğ‚ [ inf. mut. ğ€²ğ€„ğ€ğ€‰ğ€¸ ğ‚[ ğ€€ğ€«ğ€Š[ ğ€¢ğ€™ğ€°[ inf. mut."

# Test LB.A.26
# Scenario: Test that 'fragmentum C' and 'fragmentum D' are correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.32: Tokenise each instance of 'fragmentum C'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.33: Tokenise each instance of 'fragmentum D'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "fragmentum A fragmentum B sup. mut. sup. mut. ]-na 1 i-[ ]so-i-[ ko-wa   1[ ]ku-mi-[â€¢]-du 1[ inf. mut. vac. [ vac. [ fragmentum C fragmentum D sup. mut. sup. mut. ]di-mi[ ]vac. ]*56-za[ ]vac. inf. mut. inf. mut." : "fragmentum A fragmentum B sup. mut. sup. mut. ]ğ€™ 1 ğ€‚[ ]ğ€°ğ€‚[ ğ€’ğ€·   1[ ]ğ€“ğ€–[â€¢]ğ€‰ 1[ inf. mut. vac. [ vac. [ fragmentum C fragmentum D sup. mut. sup. mut. ]ğ€‡ğ€–[ ]vac. ]ğ–ğ€¼[ ]vac. inf. mut. inf. mut."

# Test LB.A.27
# Scenario: Test that 'deest' is correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.34: Tokenise each instance of 'deest'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "sup. mut. ]-deest-[ inf. mut." : "sup. mut. ]deest[ inf. mut."

# Test LB.A.28
# Scenario: Test that 'prior pars sine regulis' and 'â€¢' are correctly printed in annotated scenarios.
# Requirements mapping
    # LB.35: Tokenise each instance of 'prior pars sine regulis'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.57: Tokenise each instance of 'â€¢'. Represent this text as is in the annotated output, and represent as wildcard (i.e. '%') in regularised output.

    "]-ke-ra2-u-na , e-ra[ ]â€¢ po-se-da-o-neâŒ âŒŸre-ko-no 6 [ *146 18[ ] LANA 2 M 2[ AÂ±REÂ±PA V 4[ ]â€¢ 1 OVIS:m 1 OVIS:f 1 CAP:f[ qs SUS+KA 2 SUS:f 4[ ]â€¢ 1 FAR T 1 V [ qs VIN 5 TELA [ ] 1 TELA+PA 1 vac. vac. vac. [ ]3[ ]-we-e-a2[ inf. mut. v. prior pars sine regulis ]e-ke-me-de , do[ ]du-ru-wo-qo deest vac. vac. vac. vac. vac. vac." : "]ğ€ğˆğ€„ğ€™ , ğ€ğ€¨[ ]â€¢ ğ€¡ğ€®ğ€…ğ€ƒğ€šâŒ âŒŸğ€©ğ€’ğ€œ 6 [ ğ‚ 18[ ] ğ‚ 2 ğ„¸ 2[ ğ‚˜ ğ„¾ 4[ ]â€¢ 1 ğ‚‡ 1 ğ‚† 1 ğ‚ˆ[ qs ğ‚+ğ€ 2 ğ‚Š 4[ ]â€¢ 1 ğ€ ğ„¼ 1 ğ„¾ [ qs ğ‚– 5 ğ‚§ [ ] 1 ğ‚§+ğ€ 1 vac. vac. vac. [ ]3[ ]ğ€¸ğ€ğ€[ inf. mut. v. prior pars sine regulis ]ğ€ğ€ğ€•ğ€† , ğ€ˆ[ ]ğ€‰ğ€¬ğ€ºğ€¦ deest vac. vac. vac. vac. vac. vac."

# Test LB.A.29
# Scenario: Test that 'reliqua pars sine regulis' is correctly printed in annotated scenarios.
# Requirements mapping
    # LB.36: Tokenise each instance of 'reliqua pars sine regulis'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "sup. mut. ]-vest.-[ ]-na-ro GRA 5 ]--do-we-i , ma-so-qe GRA 8 ] vac. ] GRA 402 OLIV+A 52 reliqua pars sine regulis" : "sup. mut. ]vest.[ ]ğ€™ğ€« ğ‚ 5 ]ğ€ˆğ€¸ğ€‚ , ğ€”ğ€°ğ€¤ ğ‚ 8 ] vac. ] ğ‚ 402 ğ‚+ğ€€ 52 reliqua pars sine regulis"

# Test LB.R.30
# Scenario: Test that 'angustum' and '[â€¢~]' are correctly printed in annotated scenarios.
# Requirements mapping
    # LB.37: Tokenise each instance of 'angustum'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.59: Tokenise each instance of '[â€¢~]'. Represent this text as is in the annotated output, and represent a single wildcard (i.e. '%') in regularised output.
    
    "]we-ke , ke-tu-wo-e o-two-we-o , ke-ro-si-ja a3-nu-me-no VIR 1[ o-two-we-o , ke-ro-si-ja qo-te-ro VIR[ 1 o-two-we-o , ke-ro-si-ja , a2-e-ta [VIR 1 o-two-we-o , ke-ro-si-ja , o-du-*56-ro [VIR 1 a-pi-jo-to , ke-ro-si-ja , ku-te-re-u VIR[ 1 a-pi-jo-to , ke-ro-si-ja , o-wo-to VIR 1 a-pi-jo-to , ke-ro-si-ja , a-ra-i-jo VIR 1 a-pi-jo[-to ] ke-ro-si-ja , ri-zo VIR 1 ta-we[-si-jo-]jo , ke-ro-si-ja , wa-[ ] VIR 1 ta-we-si[-jo-]jo , ke-ro-si-ja , [ ] VIR 1 ta-we-si-jo-jo , ke-ro-si-ja [ ]wa-ne-u VIR 1 a-pi-qo[-ta-o] , ke-ro-si-ja , a3-so-ni-jo VIR 1 a[-pi-qo-ta-o ] ke-ro-si-ja , a[ ]te VIR[ 1 ]ke-ro-si-ja , 
    a[ ] VIR 1 ke-ro-]si-ja , [â€¢~]me-ka-[â€¢] VIR 1 a-[ ke-ro-]si-ja , o-pa-[ ]vac.[ VIR 1 vac.[ ] vac. vac. [ ] vac. v. ta-we-si-jo-jo , ke-ro-si-ja , te-wa[ VIR 1 ta-]we-si-jo-jo , ke-ro-si-ja , tu-ru-we-u VIR 1 ] angustum ta-]we-si-jo-jo , ke-ro-si VIR 20 a-pi-qo-ta-o , ke-ro-si-ja VIR 17 a-pi-o-to , ke-ro-si-ja VIR [1]8âŒŸ o-to-wo[-o ke-]ro-si-ja VIR [1]4 angustum [ ] [ ] ka-ma-e[-we] VIR 10" : 
    "]ğ€¸ğ€ , ğ€ğ€¶ğ€ºğ€ ğ€ƒğğ€¸ğ€ƒ , ğ€ğ€«ğ€¯ğ€Š ğğ€ğ€•ğ€œ ğ‚€ 1[ ğ€ƒğğ€¸ğ€ƒ , ğ€ğ€«ğ€¯ğ€Š ğ€¦ğ€³ğ€« ğ‚€[ 1 ğ€ƒğğ€¸ğ€ƒ , ğ€ğ€«ğ€¯ğ€Š , ğ€ğ€ğ€² [ğ‚€ 1 ğ€ƒğğ€¸ğ€ƒ , ğ€ğ€«ğ€¯ğ€Š , ğ€ƒğ€‰ğ–ğ€« [ğ‚€ 1 ğ€€ğ€ ğ€ğ€µ , ğ€ğ€«ğ€¯ğ€Š , ğ€“ğ€³ğ€©ğ€„ ğ‚€[ 1 ğ€€ğ€ ğ€ğ€µ , ğ€ğ€«ğ€¯ğ€Š , ğ€ƒğ€ºğ€µ ğ‚€ 1 ğ€€ğ€ ğ€ğ€µ , ğ€ğ€«ğ€¯ğ€Š , ğ€€ğ€¨ğ€‚ğ€ ğ‚€ 1 ğ€€ğ€ ğ€[ğ€µ ] ğ€ğ€«ğ€¯ğ€Š , ğ€ªğ€¿ ğ‚€ 1 ğ€²ğ€¸[ğ€¯ğ€]ğ€ , ğ€ğ€«ğ€¯ğ€Š , ğ€·[ ] ğ‚€ 1 ğ€²ğ€¸ğ€¯[ğ€]ğ€ , ğ€ğ€«ğ€¯ğ€Š [ ] ğ‚€ 1 ğ€²ğ€¸ğ€¯ğ€ğ€ , ğ€ğ€«ğ€¯ğ€Š [ ]ğ€·ğ€šğ€„ ğ‚€ 1 ğ€€ğ€ ğ€¦[ğ€²ğ€ƒ] , ğ€ğ€«ğ€¯ğ€Š , ğğ€°ğ€›ğ€ ğ‚€ 1 ğ€€[ğ€ ğ€¦ğ€²ğ€ƒ ] ğ€ğ€«ğ€¯ğ€Š , ğ€€[ ]ğ€³ ğ‚€[ 1 ]ğ€ğ€«ğ€¯ğ€Š , 
    ğ€€[ ] ğ‚€ 1 ğ€ğ€«]ğ€¯ğ€Š , ğ€•ğ€% ğ‚€ 1 ğ€€% ğ€ğ€«%ğ€¯ğ€Š ğ€ƒğ€% %% ğ‚€ 1 % % % % ğ€²ğ€¸ğ€¯ğ€ğ€ ğ€ğ€«ğ€¯ğ€Š ğ€³ğ€·% ğ‚€ 1 ğ€²%ğ€¸ğ€¯ğ€ğ€ ğ€ğ€«ğ€¯ğ€Š ğ€¶ğ€¬ğ€¸ğ€„ ğ‚€ 1 % ğ€²%ğ€¸ğ€¯ğ€ğ€ ğ€ğ€«ğ€¯ ğ‚€ 20 ğ€€ğ€ ğ€¦ğ€²ğ€ƒ ğ€ğ€«ğ€¯ğ€Š ğ‚€ 17 ğ€€ğ€ ğ€ƒğ€µ ğ€ğ€«ğ€¯ğ€Š ğ‚€ %1%8 ğ€ƒğ€µğ€º%ğ€ƒ ğ€%ğ€«ğ€¯ğ€Š ğ‚€ %1%4 % % % % ğ€ğ€”ğ€%ğ€¸% ğ‚€ 10"


# Test LB.A.10
# Scenario: Check that 'vacat' is correctly printed in annotated scenarios.
# Requirements mapping:
    # LB.17: Tokenise each instance of 'vacat'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "] vacat [" : "] vacat ["   

# Test LB.A.11
# Scenario: Check that 'vest.' is handled as a wildcard, and 'vac.' is printed in annotated scenarios.
# Requirements mapping:
    # LB.16: Tokenise each instance of 'vac.'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.18: Tokenise each instance of 'vest.'. Represent this text as is in the annotated output, and represent as wildcard (i.e. '%') in regularised output.
    # What about '\u00a0'?

    "] vest ., / su-ri-mo , u-ta-jo-jo , o OVIS m 85[\u00a0] vac ." : "] vest., / ğ€±ğ€ªğ€— , ğ€„ğ€²ğ€ğ€ , ğ€ƒ ğ‚‡ 85[ ] vac."
    # "]-vest.-[ ]-re-po-so [ ka-ri-se-u [VIR 1] wi-je-mo VIR 1 pi-ro-qa-wo-[ qe-te-se-u VIR [1] no-da-ro VIR 1 a-ku-ri-jo-[ vac. [ ]-to-so VIR 7" : "]vest.[ ]ğ€©ğ€¡ğ€° [ ğ€ğ€ªğ€®ğ€„ [ğ‚€ 1] ğ€¹ğ€‹ğ€— ğ‚€ 1 ğ€ ğ€«ğ€£ğ€º[ ğ€¤ğ€³ğ€®ğ€„ ğ‚€ [1] ğ€œğ€…ğ€« ğ‚€ 1 ğ€€ğ€“ğ€ªğ€[ vac. [ ]ğ€µğ€° ğ‚€ 7"

# Test LB.A.13
# Scenario: Check that 'v.' is printed in annotated scenarios.
# Requirements mapping:
    # LB.28: Tokenise each instance of 'v.'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "v." : "v."

# Test LB.A.14
# Scenario: Check that blank spaces are removed before the full stop for 'l .' and 's .', and that the resulting 'l.' and 's.' are not printed in regularized scenarios.
# Requirements mapping:
    # LB.1: Tokenise each blank space and use to distinguish individual words. Represent as is in both annotated and regularised output.
         # The only exceptions to this is if a space appears after '*', before/after '+', or before a '.'  in an annotation (e.g. 'lat .'); spaces in these instances should be removed in both the annotated and regularized outputs.
    # LB.35: Tokenise each instance of 'l.'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.37: Tokenise each instance of 's.'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "l . s .": "l. s."

# Test LB.A.15
# Scenario: Check that 'lat.' and 'inf.' are not printed in regularized scenarios.
# Requirements mapping:
    # LB.36: Tokenise each instance of 'lat.'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.40: Tokenise each instance of 'inf.'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "l\u0323a\u0323t\u0323 . i\u0323n\u0323f\u0323 .": "lat. inf."

# Test LB.A.16
# Scenario: Check that blank spaces are removed before the full stop for 'l .' and 'i .', and that the resulting 'l.' and 'i.' are printed in annotated scenarios.
# Requirements mapping:
    # LB.1: Tokenise each blank space and use to distinguish individual words. Represent as is in both annotated and regularised output.
          # The only exceptions to this is if a space appears after '*', before/after '+', or before a '.'  in an annotation (e.g. 'lat .'); spaces in these instances should be removed in both the annotated and regularized outputs.
    # LB.35: Tokenise each instance of 'l.'. Represent this text as is in the annotated output, but do not include in the regularised output.
    # LB.39: Tokenise each instance of 'i.'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "l . i .": "l. i."

# Test LB.A.17
# Scenario: Check that 'Graffito' is printed in annotated scenarios.
# Requirements mapping:
    # LB.25: Tokenise each instance of 'Graffito'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "] Graffito [": "] Graffito ["

# Test LB.A.19
# Scenario: Check that the space is removed after the '+' sign, and the correct sign is printed in the regularized scenario.
# Requirements mapping:
    # LB.1: Tokenise each blank space and use to distinguish individual words. Represent as is in both annotated and regularised output.
          # The only exceptions to this is if a space appears after '*', before/after '+', or before a '.'  in an annotation (e.g. 'lat .'); spaces in these instances should be removed in both the annotated and regularized outputs.

    "]r\u0323o\u0323 , / da-mo GRA [ ]8 OLIV+ A 12" : "]ğ€« , / ğ€…ğ€— ğ‚ [ ]8 ğ‚+ğ€€ 12"

# Test LB.A.21
# Scenario: Check that 'deest' is printed in annotated scenarios.
# Requirements mapping:
    # LB.23: Tokenise each instance of 'deest'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "] deest [" : "] deest ["

# Test LB.A.23
# Scenario: Check that '[â€¢]' is printed in annotated scenarios.
# Requirements mapping:
    # LB.42: Tokenise each instance of '[â€¢]'. Represent this symbol as is in the annotated output, and represent as a single wildcard (i.e. '%') in regularised output.

    "]po-[\u2022] , / [ OVIS m ] 40 o OVIS m 20" : "]ğ€¡[â€¢] , / [ ğ‚‡ ] 40 ğ€ƒ ğ‚‡ 20"

# Test LB.A.24
# Scenario: Check that spaces are removed before and after '+' and the correct sign/s are printed in annotated scenarios.
# Requirements mapping:
    # LB.1: Tokenise each blank space and use to distinguish individual words. Represent as is in both annotated and regularised output.
        #   The only exceptions to this is if a space appears after '*', before/after '+', after TELA, or before a '.'  in an annotation (e.g. 'lat .'); spaces in these instances should be removed in both the annotated and regularized outputs.

    "ME + RI *211 VAS + PO 1[" : "ğ‚™ ğƒª+ğ‚“ 1["

# Test LB.A.25
# Scenario: Check that spaces are removed after 'TELA' and the correct sign/s are printed in annotated scenarios.
# Requirements mapping:
    # LB.1: Tokenise each blank space and use to distinguish individual words. Represent as is in both annotated and regularised output.
        #   The only exceptions to this is if a space appears after '*', before/after '+', after TELA, or before a '.'  in an annotation (e.g. 'lat .'); spaces in these instances should be removed in both the annotated and regularized outputs.

    "] * 161 TELA 2 [" : "] ğ‚© ğ‚§Â² ["

# Test LB.A.26
# Scenario: Check that spaces are removed both after 'TELA' and before and after '+' and the correct sign/s are printed in annotated scenarios.
# Requirements mapping:
    # LB.1: Tokenise each blank space and use to distinguish individual words. Represent as is in both annotated and regularised output.
        #   The only exceptions to this is if a space appears after '*', before/after '+', after TELA, or before a '.'  in an annotation (e.g. 'lat .'); spaces in these instances should be removed in both the annotated and regularized outputs.

    "do-ti-ja TELA 2 + PU 5\u03230[" : "ğ€ˆğ€´ğ€Š ğ‚§Â²+ğ€¢ 50["

# Test LB.A.27
# Scenario: Check that 'v.â†“' is not printed in annotated scenarios.
# Requirements mapping:
    # LB.30: Abbreviated form of verso, indicates the reverse side of the tablet, when inscribed.Â Arrow indicates direction that record is rotated to reach verso.
    "qe-te-o TELA;2-[ po-po TELA;2 4 [ v.â†“ âŸ¦a-mi-si-ja TELA;1 12âŸ§ [" : "ğ€¤ğ€³ğ€ƒ ğ‚§Â²[ ğ€¡ğ€¡ ğ‚§Â² 4 [ v.â†“ âŸ¦ğ€€ğ€–ğ€¯ğ€Š ğ‚§Â¹ 12âŸ§ ["

# Test LB.U.30
# tokenise 'vest.'
# tokenise 'vac.'
    # "]-vest.-[ ]-re-po-so [ ka-ri-se-u [VIR 1] wi-je-mo VIR 1 pi-ro-qa-wo-[ qe-te-se-u VIR [1] no-da-ro VIR 1 a-ku-ri-jo-[ vac. [ ]-to-so VIR 7" : "]vest.[ ]ğ€©ğ€¡ğ€° [ ğ€ğ€ªğ€®ğ€„ [ğ‚€ 1] ğ€¹ğ€‹ğ€— ğ‚€ 1 ğ€ ğ€«ğ€£ğ€º[ ğ€¤ğ€³ğ€®ğ€„ ğ‚€ [1] ğ€œğ€…ğ€« ğ‚€ 1 ğ€€ğ€“ğ€ªğ€[ vac. [ ]ğ€µğ€° ğ‚€ 7"

# Test LB.U.31
# Scenario: Check that 'fragmentum A' and 'fragmentum B', and checkmarks (i.e. 'X') are printed in annotated scenarios. 
# Requirements mapping:
    # LB.55: ADD DESCRIPTION
    # LB.56: ADD DESCRIPTION

    "fragmentum A sup. mut. ] X MUL 1 ]--u-ra MUL 1 X ]-na MUL 1 tu-ka-na X MUL 1 ]-ma MUL 1 te-qa-ja MUL 1 ]-ja MUL 1-[ ]-ja-mu-ta MUL 1-[ ]--ta2-no-[ inf. mut." : "fragmentum A sup. mut. ] X ğ‚ 1 ]ğ€„ğ€¨ ğ‚ 1 X ]ğ€™ ğ‚ 1 ğ€¶ğ€ğ€™ X ğ‚ 1 ]ğ€” ğ‚ 1 ğ€³ğ€£ğ€Š ğ‚ 1 ]ğ€Š ğ‚ 1[ ]ğ€Šğ€˜ğ€² ğ‚ 1[ ]ğ‹ğ€œ[ inf. mut."

# Test LB.U.32
# Scenario: Check that 'v.â†“' is printed in annotated scenarios.
# Requirements mapping:
    # LB.31: Tokenise each instance of 'v.â†’'. Represent this text as is in the annotated output, but do not include in the regularised output.

    "ne-wo , za-we-[ v.â†’ ] a-ro-we a-nu-to" : "ğ€šğ€º , ğ€¼ğ€¸[ v.â†’ ] ğ€€ğ€«ğ€¸ ğ€€ğ€ğ€µ"

# Test LB.U.33
# Scenario: Check that '<' and '>' are printed in annotated scenarios.
# Requirements mapping:
    # LB.27: Tokenise each instance of angle brackets (i.e. '<' and '>'). Represent this text as is in the annotated output. Do not include these symbols, or any other text that they contain, in the reguarised ouput.
    "] <OVIS:m> 69 OVIS:f 30 [ ]-e-ke-me-de , / tu-ni-ja , pa OVIS:m 1" : "] <ğ‚‡> 69 ğ‚† 30 [ ]ğ€ğ€ğ€•ğ€† , / ğ€¶ğ€›ğ€Š , ğ€ ğ‚‡ 1" # https://liber.cnr.it/tablet/view/3172?wl=12765
    # "]-o-pe-ro *209VAS 'ME<Â±RI>' 5 [" : "]ğ€ƒğ€Ÿğ€« ğƒ¨ ğ‚™ 5" # https://liber.cnr.it/tablet/view/4215?wl=23278

# Test LB.U.34
# Checking mapping of 'MEÂ±RI'
    "]-i-to , / da-nwa MEÂ±RI *209VAS+A 16 *172 8" : "]ğ€‚ğ€µ , / ğ€…ğ… ğ‚™ ğƒ¨+ğ€€ 16 ğ‚´ 8"

# Test LB.U.35
# Checking ' ' signs included
    "pa-si-te-o-i / me-ri *209VAS 1 da-pu2-ri-to-jo , / po-ti-ni-ja 'me-ri' *209VAS 1" : "ğ€ğ€¯ğ€³ğ€ƒğ€‚ / ğ€•ğ€ª ğƒ¨ 1 ğ€…ğ†ğ€ªğ€µğ€ , / ğ€¡ğ€´ğ€›ğ€Š 'ğ€•ğ€ª' ğƒ¨ 1"


# Test LB.U.37
# Include erasures 'âŸ¦xxxâŸ§'
# Include lat. inf.
    "] âŸ¦*209VAS+A 270âŸ§-[ v.â†“ ]-290 KE 200-[ lat. inf. ]-ku-do-ni-jo , [" : "] âŸ¦ğƒ¨+ğ€€ 270âŸ§[ v.â†“ ]290 ğ€ 200[ lat. inf. ]ğ€“ğ€ˆğ€›ğ€ , ["

# Test LB.U.38
# Include 'X'
    "] e-ko-so OVIS:m 100 LANA [ ]-da-ro , / X LANA [ lat. inf. ]-a3 [" : "] ğ€ğ€’ğ€° ğ‚‡ 100 ğ‚ [ ]ğ€…ğ€« , / X ğ‚ [ lat. inf. ]ğ ["

# Test LB.U.39
# Test TELAs
    "]-a-ro2-e TELA;3+PU [ ] me-sa-ta , TELA;x+PU-[" : "]ğ€€ğŠğ€ ğ‚§Â³+ğ€¢ [ ] ğ€•ğ€­ğ€² , ğ‚§Ë£+ğ€¢["

# Test LB.U.40
# Include â— = 'puncta'
# Include [â€¢~â€¢]
     # https://liber.cnr.it/tablet/view/4230?wl=23478,23481,23485
    "[â€¢~â€¢] [ wi-tu-ri-jo , / a-mo-te-re [" : "[â€¢~â€¢] [ ğ€¹ğ€¶ğ€ªğ€ , / ğ€€ğ€—ğ€³ğ€© ["

# Test LB.U.41
# Ignore '</em>'
# Include 'fragmentum A' and 'fragmentum B'
# Include vacat
    "fragmentum A fragmentum B sup. mut. sup. mut.</em> ]--to-[ ]-da-*22-to HORD [ ] 'da-*22-to' HORD 2 da-]-*22-to HORD-[ ]--ro 'da-*22-to' HORD 2 inf. mut. ]--ri 'da-*22-to' HORD 2 ] vac. inf. mut." : "fragmentum A fragmentum B sup. mut. sup. mut. ]ğ€µ[ ]ğ€…ğ’ğ€µ ğ‚ [ ] 'ğ€…ğ’ğ€µ' ğ‚ 2 ğ€…]ğ’ğ€µ ğ‚[ ]ğ€« 'ğ€…ğ’ğ€µ' ğ‚ 2 inf. mut. ]ğ€ª 'ğ€…ğ’ğ€µ' ğ‚ 2 ] vac. inf. mut."
    "fragmentum A fragmentum B vacat [ sup. mut. e-me-si-jo-jo-[ ] 3-[ pa-na-so GRA 100-[ ]-vac.-[ ta-ra-qo GRA [ inf. mut. ta-u-pa-du-we GRA-[ a-ro-ja-[ pu-na-so-[ inf. mut." : "fragmentum A fragmentum B vacat [ sup. mut. ğ€ğ€•ğ€¯ğ€ğ€[ ] 3[ ğ€ğ€™ğ€° ğ‚ 100[ ]vac.[ ğ€²ğ€¨ğ€¦ ğ‚ [ inf. mut. ğ€²ğ€„ğ€ğ€‰ğ€¸ ğ‚[ ğ€€ğ€«ğ€Š[ ğ€¢ğ€™ğ€°[ inf. mut."

# Test LB.U.44
# Mid-word ']'
    "po-]-ki-ro-nu-ka , '*161' TELA;2 3 ki-ri-ta , / e-ru-ta-ra-pi , *161 TELA;3 [ ] e-ru-ta-ra-pi [ ]-TELA;x 2 ke-ro-ta , / *161 ki-to-na TELA;x-[" : "ğ€¡]ğ€‘ğ€«ğ€ğ€ , 'ğ‚©' ğ‚§Â² 3 ğ€‘ğ€ªğ€² , / ğ€ğ€¬ğ€²ğ€¨ğ€  , ğ‚© ğ‚§Â³ [ ] ğ€ğ€¬ğ€²ğ€¨ğ€  [ ]ğ‚§Ë£ 2 ğ€ğ€«ğ€² , / ğ‚© ğ€‘ğ€µğ€™ ğ‚§Ë£["

# Test LB.U.45
# Test 'o'
    "]-jo-zo CROC P 3 o P 6-[" : "]ğ€ğ€¿ ğ‰ ğ„º 3 ğ€ƒ ğ„º 6["

# Test LB.U.46
# Include 'reliqua pars sine regulis'
    "sup. mut. ]-vest.-[ ]-na-ro GRA 5 ]--do-we-i , ma-so-qe GRA 8 ] vac. ] GRA 402 OLIV+A 52 reliqua pars sine regulis" : "sup. mut. ]vest.[ ]ğ€™ğ€« ğ‚ 5 ]ğ€ˆğ€¸ğ€‚ , ğ€”ğ€°ğ€¤ ğ‚ 8 ] vac. ] ğ‚ 402 ğ‚+ğ€€ 52 reliqua pars sine regulis"

# Test LB.U.47
# Include 'supra sigillum'
    "RU supra sigillum" : "ğ€¬ supra sigillum"

# Test LB.U.48
# Update rules
# Closed sqaure brackets with text inside and no spaces are ignored, e.g. '[â€¢~â€¢~â€¢~â€¢]' becomes '%%%%' and [o-]-pi becomes 'ğ€ƒğ€ '
# However, square brackets that are not closed/have spaces between, are still treated as wildcards 'i-[-jo ]-wo' becomes 'ğ€‚%ğ€ %ğ€º', and 'a-[ ]' becomes 'ğ€€% %' 
# Complicated text because of annotations (mainly 'ijo')
# https://liber.cnr.it/tablet/view/697
    "sup. mut. ] i-[-jo ]-wo , a-[ ] wa-du-na , [â€¢~â€¢~â€¢~â€¢] ]--to , e-[ ] vac. ]-sa-ka-ri-jo , [ ] vac. i-jo i-jo [o-]-pi / di-zo , pi-ma-na-ro , zo-wi-jo 1 a-tu-qo-te-ra-to 1-[ i-jo o-pi / ri-zo , pi-ma-na-ro pi-ro-i-ta 1 o-pi / pa-ka , di-wa-jo 1 ]-pi / o-na-se-u 1 ri--[ ]-wi-du 1 ke--[ ]-za-[ inf. mut." : "sup. mut. ] ğ€‚[ğ€ ]ğ€º , ğ€€[ ] ğ€·ğ€‰ğ€™ , [â€¢~â€¢~â€¢~â€¢] ]ğ€µ , ğ€[ ] vac. ]ğ€­ğ€ğ€ªğ€ , [ ] vac. ğ€‚ğ€ ğ€‚ğ€ [ğ€ƒ]ğ€  / ğ€‡ğ€¿ , ğ€ ğ€”ğ€™ğ€« , ğ€¿ğ€¹ğ€ 1 ğ€€ğ€¶ğ€¦ğ€³ğ€¨ğ€µ 1[ ğ€‚ğ€ ğ€ƒğ€  / ğ€ªğ€¿ , ğ€ ğ€”ğ€™ğ€« ğ€ ğ€«ğ€‚ğ€² 1 ğ€ƒğ€  / ğ€ğ€ , ğ€‡ğ€·ğ€ 1 ]ğ€  / ğ€ƒğ€™ğ€®ğ€„ 1 ğ€ª[ ]ğ€¹ğ€‰ 1 ğ€[ ]ğ€¼[ inf. mut."

# Test LB.U.49
# Include 'Î±', 'Î²', 'Î³', 'supra sigillum'
    "Î± JAC supra sigillum Î² o-pa Î³ pa-ta-ja" : "Î± ğƒ˜ supra sigillum Î² ğ€ƒğ€ Î³ ğ€ğ€²ğ€Š"

# Test LB.U.50
    # HELP
#    "sup. mut. ?OVIS]-:m ["
#    "]-si 1 tu 1 ki-zo 1 MUL 3 TELA-[;1+TE ]-a-ma-no--[ ]-1 o-ri-mo MUL 3 TELA;1+TE 1 pu-zo , ti-no , pi-ja-mu-nu MUL-[ ]-ni-ta , o-sa-po-to MUL 3 TELA-[;1]-+TE 1 [ ] vac. ["

# Test LB.U.51
# include CMS seal impression annotations e.g. 'CMS VS1B 049' >> This is the only case.
    "Î± A supra sigillum CMS VS1B 049 Î² a-pe-we-de" : "Î± ğ€€ supra sigillum CMS VS1B 049 Î² ğ€€ğ€Ÿğ€¸ğ€†"

# Test LB.U.52
# Include 'deest'
    "sup. mut. ]-deest-[ inf. mut." : "sup. mut. ]deest[ inf. mut."

# Test LB.U.53
    "HORD T 1 NI V 3 FAR V 2 VIN V 2 a-ro-do-ro-o , / wa-ke-ta , HORD T 1 NI V 3 OLE V 1 v.â†“ MEÂ±RI Z 2" : "ğ‚ ğ„¼ 1 ğ€› ğ„¾ 3 ğ€ ğ„¾ 2 ğ‚– ğ„¾ 2 ğ€€ğ€«ğ€ˆğ€«ğ€ƒ , / ğ€·ğ€ğ€² , ğ‚ ğ„¼ 1 ğ€› ğ„¾ 3 ğ‚• ğ„¾ 1 v.â†“ ğ‚™ ğ„¿ 2"

# Test LB.U.54
    # Include qs (quantum sufficit)
    "]-ke-ke-me-na-[ , ko-]-to-na GRA qs ] vac." : "]ğ€ğ€ğ€•ğ€™[ , ğ€’]ğ€µğ€™ ğ‚ qs ] vac."

# Test LB.U.55
# Include âŒ and âŒŸ
    "e-ke-qe ]-o-na-to , ke-ke-me-naâŒ âŒŸko-to-na GRA qs ] vac.": "ğ€ğ€ğ€¤ ]ğ€ƒğ€™ğ€µ , ğ€ğ€ğ€•ğ€™âŒ âŒŸğ€’ğ€µğ€™ ğ‚ qs ] vac."


